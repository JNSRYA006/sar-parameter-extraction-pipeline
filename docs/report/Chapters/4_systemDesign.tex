%****************************************************
%	CHAPTER 4 - PIPELINE DESIGN
%****************************************************
\chapter{Pipeline Design}
\label{chap:systemDesign}

This chapter's objective is to detail the core design process of this project, a wave parameter extraction pipeline. The fundamental design which needed to be achieved was the extraction of wave parameters from \acs{sar} data. In order to achieve this, 

% \begin{figure}[H]
%     \centering
%     \resizebox{0.9\linewidth}{!}{\input{Figures/PipelineDesign/wholeProject}}
%     \caption{Block Diagram in tex}
%     \label{fig:testPlotBlock}
% \end{figure}

% \begin{figure}[H]
%    \centering
%    %\begin{tabular}{@{}c@{\hspace{.2cm}}c@{}}
%        \includegraphics[page=1,width=.9\linewidth]{Figures/PipelineDesign/overall_project.pdf}
%    %\end{tabular}
%  \caption{Test}
%  \label{fig:Test}
% \end{figure}


This chapter begins by providing an overview of the entire pipeline - part of which falls outside of the scope of this project, however, this context is relevant in terms of giving context to the desired results for this project in the context of the broader goals of this pipeline. Each subsequent section will unpack the five main sub-modules within the pipeline in a respective section. Each of these sections will further break down the sub-module into smaller blocks which make up the sub-module. The use of block diagrams allows the process the be understood in terms of the flow of the pipeline, and block diagrams are used throughout this chapter to break down higher-level processes. The variable and function names utilised in this chapter, match those used in the \textsc{Matlab} pipeline.

\section{Overview} \label{sec:systemDesign.overview}

As detailed in xxx, this project required wave parameter extraction for use in a sea ice parameter extraction pipeline. This entire system design is shown as a block diagram in Figure \ref{fig:systemDesign.wholeProject}. It is evident from Figure \ref{fig:systemDesign.wholeProject}, which parts of the \acs{sar} sea ice parameter are relevant to this project. A more detailed block diagram of the wave parameter extraction process is shown in Figure \ref{fig:systemDesign.scope} and within this pipeline, five main functional blocks were identified and are highlighted by five unique colours. [ADD WAVE SPECTRUM GENERATION PIECES] [MENTION USE OF STRUCTURES THROUGHT]
% Will still change
\begin{figure}[H]
    \centering
    \includegraphics[width=.95\linewidth]{Figures/PipelineDesign/overall_project.pdf}
    \caption{Pipeline system design in the context of the entire parameter extraction process. The scope of this project is shown in black text, with parts of the pipeline outside of the scope, shown in grey.}
    \label{fig:systemDesign.wholeProject}
\end{figure}

% Word better and slim down - ADD DISCUSSION ON WAVE SPECTRUM GENERATION
The five functional blocks were identified as \textsc{pre-processing}, \textsc{metadata extraction}, \textsc{\acs{sar} spectrum calculation}, \textsc{wave spectrum generation}, and \textsc{inversion}. The \textsc{pre-processing} block involves the use of the \ac{snap} Toolbox developed by \ac{esa} as well as \textsc{Matlab}, developed by MathWorks Inc. The \textsc{pre-processing} block reads in a downloaded \acs{sar} Level-1 \ac{grd} data file and outputs a \textsc{Matlab} structure array\footnote{In \textsc{Matlab}, a structure array is a type of data that organises related data into groups. These groups are indexed using an associated field value which can hold any particular data type. More information on structure arrays can be found in the \href{https://www.mathworks.com/help/matlab/ref/struct.html}{\textsc{Matlab} documentation}. The rest of this report will refer to structure arrays simply as structures.} of \lstinline[columns=fixed]{n} equal-sized transects. These equal-sized transects can be input to the \textsc{inversion} block. The output \ac{netcdf} file from \acs{snap} is used to generate views of \acs{sar} data in \textsc{Matlab}, as well as storing the metadata for the \textsc{metadata extraction} block. The \ac{netcdf} file is read by the \textsc{metadata extraction} block and outputs the desired metadata values required for the \textsc{\acs{sar} spectrum calculation} block. The \textsc{\acs{sar} spectrum calculation} block reads in a wave spectrum sourced from \ac{ncep} and generates a \acs{sar} spectrum of the provided wave spectrum. This generated \acs{sar} spectrum is input to the \textsc{inversion} block along with the output of the \textsc{metadata extraction} block. The \textsc{inversion} block outputs the wave parameters from the input pre-processed \acs{sar} data.
% Will still change
\begin{figure}[H]
    \centering
    \includegraphics[width=.95\linewidth]{Figures/PipelineDesign/4022_pipeline.pdf}
    \caption{Pipeline system design for the scope of this project broken down further than the entire pipeline shown in Figure \ref{fig:systemDesign.wholeProject}. All the required metadata and external models are shown, along with the part of the process that they are required.}
    \label{fig:systemDesign.scope}
\end{figure}
%====================================================
% PRE-PROCESSING
%====================================================
\section{Pre-processing} \label{sec:systemDesign.preProcessing}


\subsection{Overview} \label{subsec:systemDesign.preProcessing.Overview}

The pre-processing block of the pipeline was designed in a hybrid manner, with part of the pre-processing done in the \ac{snap} toolbox developed by \ac{esa} prior to the use of \textsc{Matlab} tools. The pre-processing block was designed to have an overall function of reading in \ac{s1a} data, apply the desired pre-processing techniques to the \acs{sar} data, and take 512x512 pixel sized transects of this larger \acs{sar} data. The applied pre-processing techniques to calibrate \acs{sar} data for wave parameter extraction were on the recommendation of Giacomo De Carolis and Francesca De Santi of the \acs{irea}, however, discussion around the use of different processing techniques is presented in Chapter \ref{chap:discussion}. The design of this block was designed to keep pre-processing outside of the \textsc{Matlab} environment to a minimum, through the use of external tools. 

The pre-processing block had six notable stages: Thermal noise calibration of \acs{s1a} \acs{grd} data, radiometric calibration of these data, extraction of individual pixel incidence angle, exporting calibrated \acs{grd} data to a usable format for \textsc{Matlab}, reading in the exported data, and taking 512x512 pixel transects of the larger \acs{sar} data. The flow of this block of the pipeline is shown graphically in Figure \ref{fig:systemDesign.preProcessing.blockDiagram}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.95\linewidth]{Figures/PipelineDesign/pre_processing.pdf}
    \caption{Block diagram depicting an expanded pre-processing sub-block of Figure \ref{fig:systemDesign.scope}}
    \label{fig:systemDesign.preProcessing.blockDiagram}
\end{figure}

\subsection{Thermal Noise Calibration} \label{subsec:systemDesign.preProcessing.thermalNoise}

After obtaining \acs{grd} \acs{sar} data from \href{scihub.copernicus.eu/dhus/#/home}{Copernicus SciHub}, the first sub-block of the pre-processing block was Thermal Noise Calibration. \acs{s1a} data contains large amounts of thermal noise and as such, \acs{snap} contains a built-in function called \lstinline{S-1 Thermal Noise Removal}. For this block, this function was implemented in \acs{snap} Desktop and is detailed in \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/[pipeline.mlx]}{\lstinline{pipeline.mlx}}.

\subsection{Radiometric Calibration} \label{subsec:systemDesign.preProcessing.radiometric}

After removing thermal noise from \acs{grd} \acs{sar} data, the second sub-block of the pre-processing block was Radiometric Calibration. \acs{snap} contains a built-in function called \lstinline{Calibrate} within the \lstinline{Radiometric} block of functions. For this block, this function was implemented in \acs{snap} Desktop and is detailed in \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/[pipeline.mlx]}{\lstinline{pipeline.mlx}}.

\subsection{Incidence Angle Extraction} \label{subsec:systemDesign.preProcessing.incidenceAngle}

Due to the fact that the incidence angle varies for each pixel in \acs{sar} data, this exact per-pixel incidence angle is required in order to calculate Equations \ref{eq:hh.rar.Tt_k}, \ref{eq:hh.motion.Tv_k}, which form part of the co and autocovariance functions described in Section \ref{subsec:theory.hasselmann.sarImaging}. In order to achieve this, multiple approaches were investigated. 

Firstly, the metadata file from \acs{s1a} \acs{grd} data was found to contain near and far-look incidence angles. The initial idea to extract individual pixel incidence angle values was to use \textsc{Matlab}'s built-in \lstinline{linspace} function which creates an evenly spaced vector over the range of values. This was an incorrect implementation as the incidence angle is not a linear relation to the latitude and longitude of an image. Furthermore, this method meant that each longitude of the image contained the same incidence angle value, and only the latitude of the image changed.

Secondly, a second type of metadata from \acs{s1a} \acs{grd} data was investigated. This metadata was in the form of a tie-point grid, which provided a 4x4 matrix of incidence angle data, using \lstinline{linspace} on this metadata resulted in a per-pixel incidence angle value which changed in latitude, as well as longitude which is an improvement from the first method.

Finally, tie-point grid data was exported as a band using \acs{snap} Desktop. The way in which this is achieved is detailed in \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/[pipeline.mlx]}{\lstinline{pipeline.mlx}}. These data provide a pixel-by-pixel value of the incidence angle on the \acs{s1a} data. Exporting the tie-point grid as a band, allows this band to be imported in \textsc{Matlab} using the \lstinline{ncread} function discussed in Section \ref{subsec:systemDesign.preProcessing.importData}.

In order to decide which method to use, plots of these data were generated over a range of pixel values. Figure \ref{fig:systemDesign.preProcessing.incidence}.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\linewidth}
        \centering
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/4_tiePoint_incidence}}
        \caption{Second implemented method to obtain incidence angle. 4x4 tie-point grid.}
        \label{fig:systemDesign.preProcessing.incidence.4_tie}
    \end{subfigure}   
    \begin{subfigure}{0.48\linewidth}
        \centering    
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/linspcae_incidence}}
        \caption{Second implemented method to obtain incidence angle. \lstinline{linspace} of 4x4 tie-point grid.}
        \label{fig:systemDesign.preProcessing.incidence.4_tie.linspace}        
    \end{subfigure}
    \subcaptionbox{Third implemented method to obtain incidence angle. Exported band of incidence angle tie-point grid.\label{fig:systemDesign.preProcessing.incidence.pixel_tie}}[0.48\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/pixel_tiePoint_incidence}}
    }
        \subcaptionbox{Difference between Figures \ref{fig:systemDesign.preProcessing.incidence.4_tie.linspace} and \ref{fig:systemDesign.preProcessing.incidence.pixel_tie}.\label{fig:systemDesign.preProcessing.incidence.difference}}[0.48\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/difference_incidence}}
    }   
    \caption{Comparison of incidence angle data from 28-Jul-2023 at 34.78S, 16.77E. The second two methods discussed in Section \ref{subsec:systemDesign.preProcessing.incidenceAngle} are shown visually as a coloured image corresponding to associated incidence angle values, as indicated in the respective colour bars.}
    \label{fig:systemDesign.preProcessing.incidence}
\end{figure}

% Disucssion of plots (Look in ClickUp)


\subsection{\acs{netcdf} Export} \label{subsec:systemDesign.preProcessing.exportNetCDF}
% Discuss why netcdf
\acs{snap} Desktop allows a multitude of export options for pre-processed data. The choice of export data type was narrowed down to data formats which contained metadata, as well as the \acs{sar} data. A list of these formats is shown below.

\begin{itemize}
    \item GeoTIFF
    \item BEAM-DIMAP
    \item \ac{envi}
    \item \ac{hdf}5
    \item \ac{netcdf}4
\end{itemize}

In order to decide which file format to export data as from \acs{snap} Desktop, an analysis of the compatibility of each file format with \textsc{Matlab} was done and the following was found.

A GeoTIFF file can be read into \textsc{Matlab} using the \lstinline{readgeoraster} function built into the Mapping Toolbox provided by \textsc{Matlab}. BEAM-DIMAP is a file format used by \acs{snap} products, and cannot be imported to \textsc{Matlab}. An \ac{envi} file can be read into \textsc{Matlab} to extract metadata using the \lstinline{enviinfo} function built into the Image Processing Toolbox by \textsc{Matlab}. A \acs{hdf}5 file can be displayed and read in \textsc{Matlab} using a variety of functions built into \textsc{Matlab} such as the \lstinline{h5disp} and \lstinline{h5read} functions. Finally, a \acs{netcdf}4 file can, as with \acs{hdf}5 files, be displayed and read in \textsc{Matlab} using a variety of functions built into \textsc{Matlab}.

Of the 5 export file types, only BEAM-DIMAP cannot be read into \textsc{Matlab}. Due to the desire to only use built-in \textsc{Matlab} functions and not make use of external toolboxes, this left \acs{hdf}5 and \acs{netcdf}4 as the two file types to be chosen from. Both file formats are able to be loaded as a structure in \textsc{Matlab}, and as such are both desirable choices. However, exporting \acs{sar} data from \acs{snap} was faster when exporting as \acs{netcdf} as opposed to \acs{hdf}. Furthermore, \acs{ncep} data was downloaded as a \acs{netcdf} file, and in order to keep consistency, \acs{netcdf} was chosen as the file type to export from \acs{snap} Desktop.

\subsection{Matlab Data Import} \label{subsec:systemDesign.preProcessing.importData}

The first sub-block in the \textsc{Matlab} implementation of the pre-processing block was called \lstinline{ncread}. As discussed in Section \ref{subsec:systemDesign.preProcessing.exportNetCDF}, the \acs{netcdf} file format was used for all imported data into \textsc{Matlab}. The \href{https://www.mathworks.com/help/Matlab/ref/ncread.html}{\lstinline{ncread}} \textsc{Matlab} function was used to import the exported data from \acs{snap} Desktop.

In order to access different bands within the \acs{netcdf} file, different variable names were used as a second input parameter to the \href{https://www.mathworks.com/help/Matlab/ref/ncread.html}{\lstinline{ncread}} functions. Listing \ref{code:netCDFImport} details the required variable names to extract the two bands of interest required for each subsequent block, and sub-block in Figure \ref{fig:systemDesign.scope}.

\begin{lstlisting}[caption={\textsc{Matlab} code used to import all desired bands from exported \acs{netcdf} data from \acs{snap} Desktop.},label={code:netCDFImport}]
filepath = "D:\UCT\EEE4022S\Data\CPT\export_data.nc";
VV = ncread(filepath,'Sigma0_VV'); % Intensity VV pre-processed data
th = ncread(filepath,'Incidence_Angle'); % Incidence Angle band
\end{lstlisting}

By utilising \href{https://www.mathworks.com/help/Matlab/ref/ncread.html}{\lstinline{ncread}} to extract data, this assigns both \lstinline{VV} and \lstinline{th} variables to a nxm sized matrix, where n and m respectively represent the size of the \acs{sar} data in terms of cross-range and range directions. The extraction of metadata is detailed in Section \ref{subsec:systemDesign.metadata.import}.



\subsection{Take Transects and Subdivide Data} \label{subsec:systemDesign.preProcessing.transects}

The most important part of the pre-processing for wave parameter extraction for use in sea ice parameter extraction is the ability to 'follow' the flow of ocean waves into the \acs{miz}. To achieve this, transects of a fixed size are taken of open ocean scenes as well as sea ice scenes. This allows the way in which ocean waves propagate through sea ice to be studied, and due to this, sea ice parameters are able to be extracted using the models described in Section \ref{subsec:litReview.sarCharac.seaIceWaveModelling}. As per \cite{Wadhams2004,DeSanti2018} the size of these transects should be 512x512 pixels in size. Taking transects of a larger image in \textsc{Matlab} is relatively straightforward, however, these transects need to be able to be taken at an angle to follow the direction of the visible ocean waves. If the ocean wave direction is not followed, this could cause issues in determining the way in which ocean waves are attenuated in the \acs{miz}. Along with this, the transect needs to start at a certain location of the whole scene. Due to the fact that latitude and longitude are not encoded in the \acs{s1a} \ac{grd} data, it was decided that a pixel starting position would be used to determine the starting position.

Due to the way in which \textsc{Matlab} indexes arrays, which is counter-intuitive to other programming languages, with the initial index being given a value of \textsc{1}, a check that the start location of the first transect was a valid index in the imported sarData needed to be conducted. This was achieved using a simple \lstinline{if} statement. The way in which angled transects were designed to be taken is visually represented in Figure \ref{fig:systemDesign.transects}. 


\begin{figure}[H]
    \centering
    \includegraphics[width=.65\linewidth]{Figures/PipelineDesign/transects_w_SAR.pdf}
    \caption{Implemented geometry for taking transects of full \acs{sar} scene.}
    \label{fig:systemDesign.transects}
\end{figure}

$\theta$, in Figure \ref{fig:systemDesign.transects}, represents the user-supplied angle at which to take the $n$ number of 512x512 transects measured clockwise from the +$x$-axis. $x_{1},y_{1}$ represent the user-supplied pixel starting location at which transects should be taken from. The \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/get512Transects.m}{\lstinline{get512Transects}} function was designed to incorporate all of these design decisions, and as a result, takes in the full scene of \acs{sar} data, the top left $x$ and $y$ coordinates, as well as the user-defined angle, $\theta$ and number of transects, $n$. \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/get512Transects.m}{\lstinline{get512Transects}} returns a 512x512x$n$ array of the transects of the full scene, along with a $n$x4 matrix of the corner pixel values of each transect. As well as using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/get512Transects.m}{\lstinline{get512Transects}} function to take transects of the \acs{sar} image, the function can also be used to take transects of the \lstinline{th} variable determined in Listing \ref{code:netCDFImport}. The returned variable for \lstinline{th} follows the same form as discussed above for \acs{sar} data.

In order to annotate the transects, the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/annotate512Transects.m}{\lstinline{annotate512Transects}} function was designed which allowed the user to control the colour of the transect outline, as well as text colour and need for a background on the text colour. Using both the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/get512Transects.m}{\lstinline{get512Transects}} and \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/annotate512Transects.m}{\lstinline{annotate512Transects}} functions allowed the plots in Figure \ref{fig:systemDesign.transectSample} to be generated. The ability to view individual transects is desired to be able to follow the direction of waves within the \acs{sar} scene.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.65\linewidth}
        \centering
        \includegraphics[width=\linewidth]{Figures/PipelineDesign/VVSceneWTransects.pdf}
        \caption{Full \acs{s1a} VV scene.}
        \label{fig:systemDesign.transectSample.full}
    \end{subfigure}   
    \begin{subfigure}{0.95\linewidth}
        \centering    
        \includegraphics[width=\linewidth]{Figures/PipelineDesign/VVAllTransects.pdf}
        \caption{Transects 1 through 3 of Figure \ref{fig:systemDesign.transectSample.full} taken at 30$\degree$.}
        \label{fig:systemDesign.transectSample.all}        
    \end{subfigure}
    \caption{\acs{s1a} Intensity VV data, pre-processed according to Section \ref{sec:systemDesign.preProcessing}, from 28-Jul-2023 at 34.78\,S, 16.77\,E with transects at 30$\degree$ for $x_{1},y_{1} = 1,1$ displayed and labelled. Respective individual transects are shown.}
    \label{fig:systemDesign.transectSample}
\end{figure}
% Including geometry
% \begin{figure}[H]
%     \centering
%     \begin{subfigure}{0.48\linewidth}
%         \centering
%         \includegraphics[width=\linewidth]{Figures/PipelineDesign/VVSceneWTransects.pdf}
%         \caption{Full \acs{s1a} VV scene.}
%         \label{fig:systemDesign.transectSample.full}
%     \end{subfigure}   
%     \begin{subfigure}{0.48\linewidth}
%         \centering
%         \includegraphics[width=\linewidth]{Figures/PipelineDesign/transects_w_SAR.pdf}
%         \caption{Full \acs{s1a} VV scene.}
%         \label{fig:systemDesign.transectSample.full}
%     \end{subfigure}    
%     \begin{subfigure}{0.95\linewidth}
%         \centering    
%         \includegraphics[width=\linewidth]{Figures/PipelineDesign/VVAllTransects.pdf}
%         \caption{Transects 1 through 3 of Figure \ref{fig:systemDesign.transectSample.full} taken at 30$\degree$.}
%         \label{fig:systemDesign.transectSample.all}        
%     \end{subfigure}
%     \caption{\acs{s1a} Intensity VV data, pre-processed according to Section \ref{sec:systemDesign.preProcessing}, from 28-Jul-2023 at 34.78\,S, 16.77\,E with transects at 30$\degree$ for $x_{1},y_{1} = 1,1$ displayed and labelled. Respective individual transects are shown.}
%     \label{fig:systemDesign.transectSample}
% \end{figure}

%====================================================
% METADATA EXTRACTION
%====================================================
\section{Metadata Extraction} \label{sec:systemDesign.metadata}

\subsection{Overview} \label{subsec:systemDesign.metadata.overview}

\begin{figure}[H]
    \centering
    \includegraphics[width=.85\linewidth]{Figures/PipelineDesign/metadataExtraction.pdf}
    \caption{Block diagram depicting an expanded metadata extraction sub-block of Figure \ref{fig:systemDesign.scope}}
    \label{fig:systemDesign.metadata.blockDiagram}
\end{figure}

\subsection{Data Import} \label{subsec:systemDesign.metadata.import}

The first sub-block of the metadata extraction block was called \lstinline{ncinfo}. As discussed in Section \ref{subsec:systemDesign.preProcessing.exportNetCDF}, the \acs{netcdf} file format was used for importing data into \textsc{Matlab}. The \href{https://www.mathworks.com/help/Matlab/ref/ncinfo.html}{\lstinline{ncinfo}} \textsc{Matlab} function was used to import the exported data from \acs{snap} Desktop.

In order to access the exported metadata within the \acs{netcdf} file the \href{https://www.mathworks.com/help/Matlab/ref/ncinfo.html}{\lstinline{ncinfo}} \textsc{Matlab} function was used. Listing \ref{code:netCDFImport} details the required variable name to extract the metadata for the subsequent sub-block in Figure \ref{fig:systemDesign.metadata.blockDiagram}.

\begin{lstlisting}[caption={\textsc{Matlab} code used to import metadata from exported \acs{netcdf} data from \acs{snap} Desktop.},label={code:netCDFImport.metadata}]
filepath = "D:\UCT\EEE4022S\Data\CPT\export_data.nc";
metadata = ncinfo(filepath,'metadata'); % Extract all metadata
\end{lstlisting}

Using \href{https://www.mathworks.com/help/Matlab/ref/ncinfo.html}{\lstinline{ncinfo}} to extract metadata, assigns the \lstinline{metadata} variable to a $1$x$1$ structure with all desired metadata in the \texttt{Attributes} field which can be parsed to the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/annotate512Transects.m}{\lstinline{filterAttributesNetCDF}} sub-block.


\subsection{Filter Attributes} \label{subsec:systemDesign.metadata.filter}

The \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/annotate512Transects.m}{\lstinline{filterAttributesNetCDF}} block takes in a structure containing metadata, as well as a list of strings of the desired attributes to keep from all metadata values. Exact attribute names can be found in Table \ref{tab:ap.metadataVals} in Appendix \ref{ap:metadata}. The function outputs a \texttt{1xlength(reqAttributes)} structure with two columns: \texttt{Name} and \texttt{Value}. Additional metadata formatting functions are discussed in Section \ref{sec:systemDesign.sarSpectrum} and \ref{sec:systemDesign.inversion} when required by respective \acp{mtf}.

%====================================================
% WAVE SPECTRUM GENERATION
%====================================================
\section{Wave Spectrum Generation} \label{sec:systemDesign.waveSpectrum}



\subsection{Overview} \label{subsec:systemDesign.waveSpectrum.Overview}

\begin{figure}[H]
    \centering
    \includegraphics[width=.95\linewidth]{Figures/PipelineDesign/wave_spectrum.pdf}
    \caption{Block diagram depicting an expanded wave spectrum generation sub-block of Figure \ref{fig:systemDesign.scope}.}
    \label{fig:systemDesign.wavesSpectrum.blockDiagram}
\end{figure}

\subsection{Wave Data Download} \label{subsec:systemDesign.waveSpectrum.download}

\acs{ncep} \acs{noaa} wave data is available in 6-hour intervals. These intervals are 00, 06, 12, and 18 hours in UTC time. As \acs{s1a} captures are not set to exact time intervals, a function \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{getNOAAParams}} was created which took in the \acs{s1a} capture datetime object, obtained using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{getCaptureData}} function, and outputted two strings. Both of these strings were formatted as per the \acs{url} used to download \acs{ncep} wave data. 

The way in which the closest hour value was determined was using the code extract from \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{getNOAAParams}} shown in Listing \ref{code:waveSpec.download.closestHour}. 

\begin{lstlisting}[caption={Initial implementation of \textsc{Matlab} code to extract wave parameters at certain geographical location.},label={code:waveSpec.download.closestHour}]
noaaHour = datetime(SARCaptureDate,"Format","HH:mm");
noaaHour = double(hour(noaaHour));
allowedHours = [0,6,12,18];
hourDiff = abs(allowedHours - noaaHour);
[~,hourIndex] = min(hourDiff);
nearestHour = allowedHours(hourIndex);
\end{lstlisting}

The date of the \acs{s1a} capture was extracted using \textsc{Matlab}'s built-in \lstinline{datetime} function. The form of the date and hour value required by \acs{ncep} was of the form \texttt{YYYYMMDD} and \texttt{HH} respectively. To achieve this, the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{getNOAAParams}} used basic string handling after extracting all individual values. Interestingly, isolating a month or day from a datetime object with a numeric value $<$ 10 in \textsc{Matlab}, resulted in a single character. As \acs{ncep} required two characters for both of these parameters, a simple \lstinline{if} statement checked the length of the value, and updated them accordingly if they had length 1 by prepending a \texttt{0} to the front of the single character value.

These functions allowed associated wave data to be downloaded for the corresponding \acs{s1a} data.


\subsection{GRIB2 to \acs{netcdf} Conversion} \label{subsec:systemDesign.waveSpectrum.toNetCDF}

\subsection{Defining Location} \label{subsec:systemDesign.defineLocation}

The \textsc{defineLocation} sub-block in Figure \ref{fig:systemDesign.wavesSpectrum.blockDiagram} is vital to the generation of wave spectra due to the limitation of the resolution of \acs{ncep} wave data. \acs{ncep} wave data had 0.25\,degree resolution in both latitude and longitude directions, and due to the fact that the region of interest, the CSIR directional wave buoy located at $34.20400000\degree$\,S, $18.28666944\degree$\,E is not located at the points available in \acs{ncep} wave data, a grid of latitude and longitude coordinates needed to be generated surrounding the point of interest. 

This was achieved in \textsc{Matlab} using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{createLatLonGrid}} function which creates two arrays of length 3, with the three closest latitude and longitude values based on the provided latitude, longitude and resolution of wave data. This allows surrounding wave data to be extracted as detailed in Section \ref{subsec:systemDesign.waveSpectrum.parameters}. A sample output of running Listing \ref{code:latLonExtract.grid} is shown in Listing \ref{output:latLonExtract.grid}.

\begin{lstlisting}[caption={\textsc{Matlab} code used to define grid values of latitude and longitude.},label={code:latLonExtract.grid}]
latitude = 34.20400000;     % Input latitude
longitude = -18.28666944;   % Input longitude
resolution = 0.25;          % Resolution in degrees
[grid_lat, grid_lon] = createLatLonGrid(latitude, longitude, resolution);
\end{lstlisting}

\lstinputlisting[float=h,frame=tb,caption=\textsc{Matlab} output of Listing \ref{code:latLonExtract.grid}.,label={output:latLonExtract.grid}]{Figures/PipelineDesign/latLonGrid.txt}

Listing \ref{output:latLonExtract.grid} displays a 1x3 array where the centre value represents the closest value to the given \lstinline{latitude} and \lstinline{longitude} in Listing \ref{code:latLonExtract.grid}. These arrays are used in the \textsc{extractWaveParams} sub-block to define the location over which to extract wave parameters and this process is discussed in Section \ref{subsec:systemDesign.waveSpectrum.parameters}.


\subsection{Wave Parameter Extraction} \label{subsec:systemDesign.waveSpectrum.parameters}
% Intro to structures and why we want these values

When examining the latitude and longitude values obtained from \acs{ncep}, it was noted that these data points contained decimal points of order $10^{-6}$. This proved an issue when trying to index the original downloaded wave data to access a subset of these data using the code snippet depicted in Listing \ref{code:latLonExtract.initial}. This code resulted in none of the desired data being found.

\begin{lstlisting}[caption={Initial implementation of \textsc{Matlab} code to extract wave parameters at certain geographical location.},label={code:latLonExtract.initial}]
lonVal = 45.25;
lonIndex = find(lon == lonVal);
\end{lstlisting}

In order to mitigate this, an investigation into the resolution of decimal degrees was conducted in order to match the spatial resolution of wave data to the corresponding \acs{sar} resolution. It was found that 5 decimal places allowed a worst-case resolution of 1.11\,m \cite{decimalDegreesWikipedia}. In the case of \acs{s1a}, such resolution is adequate, due to the satellite's highest spatial resolution of 9x9\,m resolution for \acs{grd} data \cite{sentinel1ProductDef}. Using this information, it was decided to update the code in Listing \ref{code:latLonExtract.initial} to the code seen in Listing \ref{code:latLonExtract.round} to allow accurate indexing of spatial coordinates without loss of spatial resolution.

\begin{lstlisting}[caption={Updated implementation of \textsc{Matlab} code to extract wave parameters at certain geographical location.},label={code:latLonExtract.round}]
lonVal = 45.25;
lonIndex = find(round(lon,5) == lonVal);
\end{lstlisting}


%\subsection{Location Definition} \label{subsec:systemDesign.waveSpectrum.defineLoc}
% Put in 1D wave spectrum Generation

\subsection{One Dimensional Wave Spectrum} \label{subsec:systemDesign.waveSpectrum.1DSpectrum}

Whilst the generation of a one-dimensional wave spectrum is only represented by one sub-block in Figure \ref{fig:systemDesign.wavesSpectrum.blockDiagram}, the generation of this spectrum is vital to forming the foundation of the two-dimensional wave spectrum which is used as a first-guess wave spectrum when minimising the cost function described in Equation \ref{eq:hh.inversion.J}. As discussed in Section \ref{subsec:theory.waves.modelling}, the most widely used wave model is the \acs{jonswap} model, and implementing this spectrum required a careful approach in order to ensure accurate modelling of waves was done using the downloaded wave data detailed in Section \ref{subsec:systemDesign.waveSpectrum.download}.

In order to construct a \acs{jonswap} wave model, $E(\omega)$, the equations detailed in Section \ref{subsec:theory.waves.modelling} were implemented in \textsc{Matlab} as outlined in the pseudocode given in Algorithm \ref{alg:jonswap} where $H_{1/3}$ and $w_{peak}$ are wave parameters as detailed in Section \ref{subsec:theory.waves.modelling} and $\omega$ is the range of frequencies over which to generate the wave spectrum for. as well as defining which geographical coordinate to construct the wave spectrum for. 
%% Mention how we know what gamma value to use


\begin{figure}[H]
  \vspace{0.5cm}
  \centering
  \captionsetup{type=figure}
  \begin{minipage}{.75\linewidth}
    \begin{algorithm}[H]
      \caption{\acs{jonswap} wave spectrum generation\label{alg:jonswap}}

      \DontPrintSemicolon
      \SetAlgoLined
      \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}\SetKwInOut{Parameter}{parameter}

      \Input{Wave parameters, $H_{1/3}$, $\omega_{peak}$ \\ Frequency range, $\omega$}
      \Output{\acs{jonswap} wave spectrum, $E(\omega)$}
      \Parameter{Peak enhancement factor, $\gamma$} % What is parameter

      \BlankLine
          \Begin{
          $g \leftarrow 9.81$\;
          $\alpha \leftarrow 0.2 \cdot H_{1/3}^{2} \cdot \frac{\omega_{peak}^{4}}{g^{2}}$ \;
          \If{$\gamma < 1$ or $\gamma > 7$}{
            % \If{$\gamma \neq 0$}{
            %     %\textbf{Display} warning message: "Warning: gamma value in wave_spectrum function outside validity range, using DNV formula"\;
            % }
            $k \leftarrow \frac{2\pi}{\omega_{0} \cdot \sqrt{H_{s}}}$\;
           \If{$k \leq 3.6$}{
                $\gamma \leftarrow 5$\;
           }
           \eIf{$k \leq 5$}{
                $\gamma \leftarrow \exp(5.75 - 1.15 \cdot k)$\;
           }{
                $\gamma \leftarrow 1$\;
           }
          }
        \For{$k$ in $1$ to $\text{length}(\omega)$}{
        \If{$\omega(k) < \omega_{peak}$}{
        $\sigma \leftarrow 0.07$\;
    }
    \Else{
        $\sigma \leftarrow 0.09$\;
    }
    
    $E1 \leftarrow \alpha \cdot g^2 \cdot (\omega(k)^{-5}) \cdot \exp\left(-\frac{5}{4} \cdot \left ( \frac{\omega_{peak}}{\omega(k)}\right)^4\right)$\;
    $\text{exponent} \leftarrow  \exp\left(- \frac{(\omega(k) - \omega_0)^2}{2 \cdot (\sigma \cdot \omega_0)^2}\right) $ \;
    $E2 \leftarrow \gamma^{\text{exponent}}$\;
    
    $E \leftarrow E1 \cdot E2$\;
}
        }
      \vspace{0.5cm}
    \end{algorithm}
  \end{minipage}
\end{figure}


Extending Algorithm \ref{alg:jonswap} to allow multiple spectra to be calculated at multiple latitudes and longitudes allowed the validity of the spectrum generation to be validated as plotting multiple wave spectra on the same set of axes allowed the way in which the wave spectra change as they approach the shore to be determined. This analysis is discussed in Section xxx and example plots obtained using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateSingleJONSWAP.m}{\lstinline{generateSingleJONSWAP}} and \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateMultipleJONSWAP.m}{\lstinline{generateMultipleJONSWAP}} functions are shown in Figure \ref{fig:systemDesign.1DSampleWaveSpectrum}. 

% \begin{figure}[H]
% \centering
% \begin{subfigure}{0.48\linewidth} % Use \begin{subfigure} instead of \begin{subfigure}
%     \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/oneDWaveSpec}}
%     \caption{\acs{jonswap} spectrum at -34S, 17.25E}
%     \label{fig:systemDesign.1DSampleWaveSpectrumSingle}   
% \end{subfigure}
% \begin{subfigure}{0.48\linewidth} % Use \begin{subfigure} instead of \begin{subfigure}
%     \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/waveSpec_toShore}}
%     \caption{\acs{jonswap} spectrum at multiple geographical locations}
%     \label{fig:systemDesign.1DSampleWaveSpectrumMultiple}  
% \end{subfigure}
% \caption{One-dimensional \acs{jonswap}, E($\omega$), wave spectra generated using \acs{ncep} wave data}
% \label{fig:systemDesign.1DSampleWaveSpectrum}
% \end{figure}

\begin{figure} [H]
    \centering
    \subcaptionbox{\acs{jonswap} spectrum at -34S, 17.25E\label{fig:systemDesign.1DSampleWaveSpectrumSingle}}[0.48\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/oneDWaveSpec}}
    }
    \subcaptionbox{\acs{jonswap} spectrum at multiple geographical locations\label{fig:systemDesign.1DSampleWaveSpectrumMultiple}}[0.48\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/waveSpec_toShore}}
    }
    \caption{One-dimensional \acs{jonswap} wave spectra, E($\omega$), generated using \acs{ncep} wave data.}
    \label{fig:systemDesign.1DSampleWaveSpectrum}
\end{figure}

\subsection{Two Dimensional Wave Spectrum} \label{subsec:systemDesign.waveSpectrum.2DSpectrum}

In order to extend the one-dimensional wave spectrum into a two-dimensional wave spectrum, a directional distribution function needed to be applied to the one-dimensional wave spectrum. This is represented in Figure \ref{fig:systemDesign.wavesSpectrum.blockDiagram} with the \lstinline{generateDirectionalSpread} block which takes in the significant wave height obtained from \acs{ncep} as well as the whole range of directions over which to define the directional spreading function. The calculation of the directional distribution function followed the definition of the $\cos^2(\theta)$ as detailed in Equations \ref{eq:directionalDistributionFunc}, \ref{eq:directionalDistributionFunc.A2}, \ref{eq:directionalDistributionFunc.sigTh} in Section \ref{subsec:theory.waves.modelling}. A plot of the directional distribution function generated using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generateDirectionalDistribution.m}{\lstinline{generateDirectionalSpread}} function is shown in Figure \ref{fig:systemDesign.direcDistributionFunction}.



% \begin{figure}[H]
%   \vspace{0.5cm}
%   \centering
%   \captionsetup{type=figure}
%   \begin{minipage}{.75\linewidth}
%     \begin{algorithm}[H]
%       \caption{Generation of a directional distribution function using the $\cos^2 \theta$ model\label{alg:cos2}}

%       \DontPrintSemicolon
%       \SetAlgoLined
%       \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}\SetKwInOut{Parameter}{parameter}
%       \SetKwRepeat{Do}{do}{while}

%       \Input{Wave parameters, $T_{1/3}$, $\omega_{peak}$ \\ Frequency range, $\omega$ \\ Number of pixels, $n$}
%       \Output{Directional distribution function, $D(\theta)$}
%       %\Parameter{Peak enhancement factor, $\gamma$} % What is parameter

%       \BlankLine
%           \Begin{
%             \For{$i$ in $1$ to $\text{length}(\omega)$}{
%                 \eIf{$\omega(i) \geq \omega_{peak}$}{
%                     $\sigma_{\theta} \leftarrow 26.9 \cdot \left( \frac{\omega(i)}{\omega_{peak}}  \right)^{0.68}$\;
%                 }{
%                     $\sigma_{\theta} \leftarrow 26.9 \cdot \left( \frac{\omega(i)}{\omega_{peak}}  \right)^{-1.05}$\;
%                 }
                    
%             }
%             $s \leftarrow \frac{2}{\sigma_{\theta}^2} - 1$\;
%             $low \leftarrow \theta_{wave} - \pi$\;
%             $high \leftarrow \theta_{wave} + \pi$\;
%             $L \leftarrow low + \text{remainder}(\theta_{wave} - low,1/n)$\;
%             $H \leftarrow high - \text{remainder}(\theta_{wave} + high,1/n)$\;
%             $\theta \leftarrow \text{transpose}(L:n:H)$\;
%             \For{$j$ in $1$ to $\text{length}(\theta)$}{
%                 $A_{2} \leftarrow \frac{\Gamma(s(j)+1)}{\Gamma(s(j)+0.5) \cdot \sqrt{2\pi}} $\;
%                 $D = \text{abs}\left( A_{2} \cdot \left( 0.5 \cdot (\theta_{wave} - \theta(j) \right)^{2 \cdot s(j)}   \right)$\;
                    
%             }            

%         }
%       \vspace{0.5cm}
%     \end{algorithm}
%   \end{minipage}
% \end{figure}


\begin{figure}[H]
    \centering
    \resizebox{0.48\linewidth}{!}{\input{Figures/PipelineDesign/directionalSpreading.tex}}
    \caption{Directional distribution function, $D(\theta)$, defined using the $\cos^2(\theta)$ model detailed in Section \ref{subsec:theory.waves.modelling}.}
    \label{fig:systemDesign.direcDistributionFunction}
\end{figure}

% Generate 2D spectrum from 1D eq
In accordance with Equation xx, the two-dimensional directional wave spectrum can be obtained by multiplying the one-dimensional wave spectrum, $E(\omega)$, with the directional distribution function, $D(\theta)$. This was achieved using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/waveSpectra/generate2DWaveSpectrum.m}{\lstinline{generate2DWaveSpectrum}} block, which took in the one-dimensional wave spectrum, and the directional distribution function and simply performed an element-wise multiplication using \textsc{Matlab}'s built-in 'dot' multiplication. This resulted in the two-dimensional wave spectrum shown in Figure \ref{fig:systemDesign.2DSampleWaveSpectrum}
% INCREASE SURF FONT SIZE
\begin{figure} [H]
    \centering
    \subcaptionbox{Contour plot of the two-dimensional wave spectrum, E($\omega,\theta$). \label{fig:systemDesign.2DSampleWaveSpectrumContour}}[0.48\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/contour_E_omega}}
    }
    \subcaptionbox{Surface plot of the two-dimensional wave spectrum, E($\omega,\theta$).\label{fig:systemDesign.2DSampleWaveSpectrum3D}}[0.62\linewidth]{
        \resizebox{\linewidth}{!}{\includesvg{Figures/PipelineDesign/surf_E_omega.svg}}
    }
    \caption{Two-dimensional \acs{jonswap} wave spectra, E($\omega,\theta$), generated using \acs{ncep} wave data.}
    \label{fig:systemDesign.2DSampleWaveSpectrum}
\end{figure}

% \begin{figure}[H]
%     \centering
%     \resizebox{0.5\linewidth}{!}{\input{Figures/Testing/surf_E_omega.tex}}
%     \caption{EOmega in tex}
%     \label{fig:testPlot4}
% \end{figure}


\subsection{Wave-number Spectrum} \label{subsec:systemDesign.waveSpectrum.waveNumberSpectrum}

Converting the two-dimensional wave spectrum generated in Section \ref{subsec:systemDesign.waveSpectrum.2DSpectrum} to a two-dimensional wave-number spectrum for use in the \ac{hh} procedure, required implementing Equation \ref{eq:waveNumberSpectrum.relateE(kx,ky)toE(w,th)_2D} in \textsc{Matlab} code. In order to implement this equation, the wave speed as described in Equation \ref{eq:linearWaveTheory.phaseVelocity} was used to determine the individual wave speed at the known depth of the region of interest. Following on from this, $n$ needed to be determined as per Equation \ref{eq:addingTwoWaves.n} to determine the group wave speed, $c_{g}$ as detailed in Equation \ref{eq:addingTwoWaves.groupVelocity}. After determining all of these variables for the specific wave spectrum, the wave-number spectrum could be determined using the relationship between the two-dimensional wave spectrum and two-dimensional wave-number spectrum as detailed in Equation \ref{eq:waveNumberSpectrum.relateE(kx,ky)toE(w,th)_2D}. To see the change between the wave spectrum, and wave-number spectrum, a contour and surface plot are provided in Figure \ref{fig:systemDesign.2DSampleWaveNumSpectrum} of the equivalent wave spectrum shown in Figure \ref{fig:systemDesign.2DSampleWaveSpectrum}.

\begin{figure} [H]
    \centering
    \subcaptionbox{Contour plot of the two-dimensional wave-number spectrum, E($k_{x},k_{y}$). \label{fig:systemDesign.2DSampleWaveNumSpectrumContour}}[0.36\linewidth]{
        \resizebox{\linewidth}{!}{\input{Figures/PipelineDesign/contour_E_k}}
    }
    \subcaptionbox{Surface plot of the two-dimensional wave-number spectrum, E($k_{x},k_{y}$).\label{fig:systemDesign.2DSampleWaveNumSpectrum3D}}[0.62\linewidth]{
        \resizebox{\linewidth}{!}{\includesvg{Figures/PipelineDesign/surf_E_k.svg}}
    }
    \caption{Two-dimensional \acs{jonswap} wave-number spectra, E($k_{x},k_{y}$), generated using \acs{ncep} wave data.}
    \label{fig:systemDesign.2DSampleWaveNumSpectrum}
\end{figure}


\section{\acs{sar} Spectrum of Ocean Waves} \label{sec:systemDesign.sarSpectrum}

\subsection{Additional Metadata Extraction} \label{subsec:systemDesign.sarSpectrum.metadata}

The \acs{mtf}s described in Section \ref{subsec:theory.hasselmann.sarImaging} each required some form of metadata from \acs{s1a} \acs{sar} data in order to be calculated. These metadata values are tabulated in Table \ref{tab:additionalMetadata} along with additional functions that were developed in order to get the extracted metadata in the correct form for implementing the \acs{mtf} equations.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{\acs{mtf}}} & \multicolumn{1}{c|}{\textbf{Required Metadata Values}} & \multicolumn{1}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Additional Metadata \\ Functions\end{tabular}}} \\ \hline
Tilt \acs{mtf} & Polarisation, Incidence Angle, Look & \begin{tabular}[c]{@{}l@{}}\href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}}, \\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}\end{tabular} \\ \hline
Hydrodynamic \acs{mtf} & \multicolumn{1}{c|}{-} & \multicolumn{1}{c|}{-} \\ \hline
\acs{rar} \acs{mtf} & Polarisation, Incidence Angle, Look & \begin{tabular}[c]{@{}l@{}}\href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}}, \\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}\end{tabular} \\ \hline
Range Velocity \acs{mtf} & Incidence Angle, Look & \begin{tabular}[c]{@{}l@{}}\href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}}, \\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}\end{tabular} \\ \hline
Velocity Bunching \acs{mtf} & \begin{tabular}[c]{@{}l@{}}Incidence Angle, Look\\ Slant Range, Capture Time\end{tabular} & \begin{tabular}[c]{@{}l@{}}\href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}},\\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}, \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{getBeta}},\\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{getSatVelocity}}\end{tabular} \\ \hline
\acs{sar} Imaging \acs{mtf} & \begin{tabular}[c]{@{}l@{}}Polarisation, Incidence Angle, Look,\\ Slant Range, Capture Time\end{tabular} & \begin{tabular}[c]{@{}l@{}}\href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}},\\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}, \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{getBeta}},\\ \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{getSatVelocity}}\end{tabular} \\ \hline
\end{tabular}
\caption{Metadata values required for each individual \acs{mtf} used in the \acs{sar} spectrum generation of ocean waves. Additional functions created are named.}
\label{tab:additionalMetadata}
\end{table}

The metadata values shown in the \textbf{Required Metadata Values} column of Table \ref{tab:additionalMetadata} are simply extracted using the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/preprocess/annotate512Transects.m}{\lstinline{filterAttributesNetCDF}} function with the appropriate required attributes chosen from Table \ref{tab:ap.metadataVals}. However, in order to implement the \acs{mtf}s correctly, certain additional functions are required to get this metadata into the correct form or be used to calculate another value.

In the case of \acs{s1a}'s look, \acs{hh} requires that the component of the wave-number vector in the radar look direction is calculated. These coordinates are chosen such that the $x$-axis represents the \acs{sar} satellite flight direction, and the $y$-axis points in the positive or negative look direction, $l$, for a left or right looking \acs{sar} satellite respectively \cite{Hasselmann1991}. Therefore, the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}} function classified the extracted look value from the metadata as either \texttt{1} or \texttt{0} where the look of \acs{s1a} was \texttt{left} or \texttt{right} respectively. After this, the \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{defineKLook}} function determined, based on the output of \href{https://github.com/JNSRYA006/sar-parameter-extraction-pipeline/blob/main/functions/hasselmann/helperFunctions.m}{\lstinline{lookDiscretise}}, whether the $y$-axis points in the positive or negative look direction, and defined the look wave-number vector, $k_{l}$, accordingly.

The calculation of the $\beta$ value proved troublesome. Remembering that $\beta$ is the ratio of slant range, $R$, and satellite velocity, $U$, the main issue with this calculation was obtaining an accurate satellite velocity. \acs{s1a} metadata provides orbit vector metadata in the form of the time, x-, y-, and z- position and velocity values. Calculating the satellite velocity, using the generic equation given in Equation \ref{eq:systemDesign.velocity}, from all orbit vectors seemed straightforward. However, it was found that calculating $U$ for each individual orbit vector, resulted in an increase in $U$ over time when the satellite's pass was ascending, and a decrease in $U$ over time when the satellite's pass was descending. 

\begin{equation} \label{eq:systemDesign.velocity}
    U = \sqrt{U_{x}^2 + U_{y}^2 + U_{z}^2}
\end{equation}

The difference between the maximum and minimum values of each individual orbit vector's velocity over Cape Point was found to be 4.6\,m/s. Further investigation revealed that at different latitudes and longitudes, this difference was minimised and amplified. [Discuss equator, and changes as moving more north or south and add plots]

\subsection{\acfp{mtf}} \label{subsec:systemDesign.sarSpectrum.mtfs}

\subsection{Co and Autocovariance Functions} \label{subsec:systemDesign.sarSpectrum.coAutoFunc}

\subsection{Spectral Expansion} \label{subsec:systemDesign.sarSpectrum.spectralExpan}



\section{Inversion} \label{sec:systemDesign.inversion}

\subsection{First-estimates} \label{subsec:systemDesign.inversion.firstEstimates}

\subsection{Cost Function Minimisation} \label{subsec:systemDesign.inversion.costFuncMinimise}


\subsection{Change in Wave Spectrum} \label{subsec:systemDesign.inversion.changeWaveSpectrum}


\subsection{Output Wave Parameters} \label{subsec:systemDesign.inversion.outputWaveParams}



\textbf{Inversion procedure}

Use the appropriate functions to calculate all the covariance functions. All MTFs need to be calculated individually and then fed in, with metadata values, into the appropriate functions. The output values are stored as a matrix. Compute the covariance functions for the spectral expansions using the appropriate functions. Then compute the FTs of these. The FTs of these can be plotted to observe the contribution to the overall SAR spectrum. 

The overall SAR spectrum is used in the inversion procedure. Obtain wave model using XXXX [update when I know wtf is going on]. The appropriate values are fed into the $\Delta F^n$ function. The cost function is then provided with all the input parameters and iterated through to provide the output wave parameters which are stored in a matrix. This can then be iterated for each transect. The appropriate plots can be generated to see attenuation and changes between wave parameters. These wave parameters are then compared to the appropriate ground truths from the CSIR. These data can be fed into the sea ice attenuation models 

%====================================================


%====================================================


%****************************************************
% END
%****************************************************
